package main
import "load_obj"
import "profile"
import "core:fmt"
import "core:math"
import "core:os"
import end "core:encoding/endian"
import clr "color"
/* offset : u16 = 0 */


obj_to_u32_array :: proc(Model : ^load_obj.Obj, buffer : ^[]u32) {

		size : [3]u32 = load_obj.get_obj_size(u32, Model)
		for &v in buffer {
				v = max(u32)
		}

		for p in Model.points {
				z := cast(u32) (p[2] + math.abs(Model.zmin))
				y := cast(u32) (p[1] + math.abs(Model.ymin)) * size[2]
				x := cast(u32) (p[0] + math.abs(Model.xmin)) * (size[2]*size[1])
				//fmt.printf("sizex: %d sizey: %d sizez: %d x: %d y: %d z: %d\n",size[0],size[1],size[2],x,y,z)
				buffer[x+y+z] = 1
				//fmt.printf("%d, %d, %d \n",x, y, z)
		}
}


obj_mcstructure :: proc(Model : ^load_obj.Obj) {

		data0 := []byte {
				0x0A, 0x00, 0x00, 0x03, 0x0E, 0x00, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x5F, 0x76, 0x65, 0x72, 
				0x73, 0x69, 0x6F, 0x6E, 0x01, 0x00, 0x00, 0x00, 0x09, 0x04, 0x00, 0x73, 0x69, 0x7A, 0x65, 0x03,
				0x03, 0x00, 0x00, 0x00,
		}

		size := load_obj.get_obj_size(u32, Model)

		data1 := []byte {
				0x0A, 0x09, 0x00, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x09, 0x0D, 0x00, 0x62, 
				0x6C, 0x6F, 0x63, 0x6B, 0x5F, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x65, 0x73, 0x09, 0x02, 0x00, 0x00, 
				0x00, 0x03,
		}

		block_fill_length : u32 = size[0]*size[1]*size[2] //TODO Check This
		blocks, _ := make([]u32, block_fill_length)
		obj_to_u32_array(Model, &blocks)
		defer delete(blocks)
		data2 : []u8 = {3}
		fill: []u32 = make([]u32, block_fill_length) // all 255
		defer delete(fill)
		for &v in fill {
				v = max(u32)
		}

		data3 := []byte {
				0x09, 0x08, 0x00, 0x65, 0x6E, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 
				0x0A, 0x07, 0x00, 0x70, 0x61, 0x6C, 0x65, 0x74, 0x74, 0x65, 0x0A, 0x07, 0x00, 0x64, 0x65, 0x66, 
				0x61, 0x75, 0x6C, 0x74, 0x09, 0x0D, 0x00, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x5F, 0x70, 0x61, 0x6C, 
				0x65, 0x74, 0x74, 0x65, 0x0A, 0x02, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x6E, 0x61, 0x6D, 0x65, 
				0x0D, 0x00, 0x6D, 0x69, 0x6E, 0x65, 0x63, 0x72, 0x61, 0x66, 0x74, 0x3A, 0x61, 0x69, 0x72, 0x0A, 
				0x06, 0x00, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x00, 0x03, 0x07, 0x00, 0x76, 0x65, 0x72, 0x73, 
				0x69, 0x6F, 0x6E, 0x01, 0x32, 0x14, 0x01, 0x00, 0x08, 0x04, 0x00, 0x6E, 0x61, 0x6D, 0x65,
		}

		material := "minecraft:stone"
		material_name_length : u16 = 15 //len(material)

		data4 := []byte {
				0x0A, 0x06, 0x00, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x00, 0x03, 0x07, 0x00, 0x76, 0x65, 0x72, 
				0x73, 0x69, 0x6F, 0x6E, 0x01, 0x32, 0x14, 0x01, 0x00, 0x0A, 0x13, 0x00, 0x62, 0x6C, 0x6F, 0x63, 
				0x6B, 0x5F, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x5F, 0x64, 0x61, 0x74, 0x61, 0x00, 
				0x00, 0x00, 0x00, 0x09, 0x16, 0x00, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x5F, 
				0x77, 0x6F, 0x72, 0x6C, 0x64, 0x5F, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x03, 0x03, 0x00, 0x00, 
				0x00, 0x26, 0x07, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x49, 0x08, 0x00, 0x00, 0x00,
		}

		using end

		of, _ := os.open("maze.mcstructure", os.O_CREATE)
		defer os.close(of)
		buf, _ := make([]u8, 4)
		buf2, _ := make([]u8, 2)
		defer delete(buf)
		defer delete(buf2)
		os.write(of, data0)
		put_u32(buf, Byte_Order.Little, size[0])
		os.write(of, buf)
		put_u32(buf, Byte_Order.Little, size[1])
		os.write(of, buf)
		put_u32(buf, Byte_Order.Little, size[2])
		os.write(of, buf)
		os.write(of, data1)
		put_u32(buf, Byte_Order.Little, block_fill_length)
		os.write(of, buf)
		//os.write(of, transmute([]u8)blocks)
		for v in blocks {
				put_u32(buf, Byte_Order.Little, v)
				os.write(of, buf)
		}
		os.write(of, data2)
		put_u32(buf, Byte_Order.Little, block_fill_length)
		os.write(of, buf)
		//os.write(of, transmute([]u8)fill)
		for v in fill {
				put_u32(buf, Byte_Order.Little, v)
				os.write(of, buf)
		}
		os.write(of, data3)
		put_u16(buf2, Byte_Order.Little, material_name_length)
		os.write(of, buf2)
		os.write(of, transmute([]u8)material)

		os.write(of, data4)
}


obj_to_u8_array :: proc(Model : ^load_obj.Obj, buffer : ^[]u8) {
		size := load_obj.get_obj_size(u64, Model)
		xlen := size[0]
		ylen := size[1]
		zlen := size[2]

		for p in Model.points {
				indx := pos_to_index(p, xlen, ylen, zlen, {Model.xmin, Model.ymin, Model.zmin})
				//fmt.printf("sizex: %d sizey: %d sizez: %d x: %d y: %d z: %d\n",size[0],size[1],size[2],x,y,z)
				buffer[indx] = 1
				//fmt.printf("%d, %d, %d \n",x, y, z)
		}
}

obj_schem :: proc(Model : ^load_obj.Obj) {
		size : [3]u64 = load_obj.get_obj_size(u64, Model)
		data1 := []byte {
				0x0A, 0x00, 0x09, 0x53, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x74, 0x69, 0x63, 0x03, 0x00, 0x0A, 0x50, 
				0x61, 0x6C, 0x65, 0x74, 0x74, 0x65, 0x4D, 0x61, 0x78, 0x00, 0x00, 0x00, 0x02, 0x0A, 0x00, 0x07, 
				0x50, 0x61, 0x6C, 0x65, 0x74, 0x74, 0x65, 0x03,
		}
		material_name_length : u16 = 15
		material: string = "minecraft:stone"
		data2 := []byte {
				0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x0D, 0x6D, 0x69, 0x6E, 0x65, 0x63, 0x72, 0x61, 0x66, 0x74, 
				0x3A, 0x61, 0x69, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x07, 0x56, 0x65, 0x72, 0x73, 
				0x69, 0x6F, 0x6E, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x06, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68,
		}
		//length
		data3 := []byte {
				0x0A, 0x00, 0x08, 0x4D, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x03, 0x00, 0x09, 0x57, 0x45, 
				0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x58, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x09, 0x57, 0x45, 
				0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x59, 0xFF, 0xFF, 0xFF, 0xFC, 0x03, 0x00, 0x09, 0x57, 0x45, 
				0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x5A, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x02, 0x00, 0x06, 0x48, 
				0x65, 0x69, 0x67, 0x68, 0x74,
		}
		//Height
		data4 := []byte {
				0x03, 0x00, 0x0B, 0x44, 0x61, 0x74, 0x61, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x00, 0x00, 
				0x0D, 0x89, 0x07, 0x00, 0x09, 0x42, 0x6C, 0x6F, 0x63, 0x6B, 0x44, 0x61, 0x74, 0x61,
		}		
		data5 := []byte {
				0x09, 0x00, 0x0D, 0x42, 0x6C, 0x6F, 0x63, 0x6B, 0x45, 0x6E, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x0A, 0x00, 0x00, 
				0x00, 0x00, 0x02, 0x00, 0x05, 0x57, 0x69, 0x64, 0x74, 0x68,
		}
		//width
		data6 := []byte {
				0x0B, 0x00, 0x06, 0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 
				0xD3, 0xFF, 0xFF, 0xFF, 0xC4, 0x00, 0x00, 0x01, 0xB0, 0x00,
		}

		block_length : u32 = cast(u32) size[0]*cast(u32)size[1]*cast(u32)size[2]+1
		blocks, _ := make([]u8, block_length)
		obj_to_u8_array(Model, &blocks)
		defer delete(blocks)

		using end

		of, _ := os.open("maze.schem", os.O_CREATE)
		defer os.close(of)
		buf, _ := make([]u8, 4)
		buf2, _ := make([]u8, 2)
		defer delete(buf)
		defer delete(buf2)


		os.write(of, data1)
		put_u16(buf2, Byte_Order.Big, material_name_length)
		os.write(of, buf2)
		os.write(of, transmute([]u8)material)
		os.write(of, data2)
		//length
		put_u16(buf2, Byte_Order.Big, cast(u16)size[0])
		os.write(of, buf2)
		os.write(of, data3)
		//height
		put_u16(buf2, Byte_Order.Big, cast(u16)size[1])
		os.write(of, buf2)
		os.write(of, data4)
		put_u32(buf, Byte_Order.Big, block_length)
		os.write(of, buf)
		os.write(of, blocks)
		os.write(of, data5)
		//width
		put_u16(buf2, Byte_Order.Big, cast(u16)size[2])
		os.write(of, buf2)
		os.write(of, data6)

}

contains :: proc(str : ^[dynamic]string, f : string) -> int {
		for s, i in str {
				if s == f {
						return i
				}
		}
		return -1
}

ruct_to_u8_array :: proc(structure : load_obj.Ruct, Model : ^load_obj.Obj, palette: ^clr.block_map) -> ([]u8, [dynamic]string) {
		profile.timeBlock()
		xlen := u64(math.ceil(Model.xmax) - math.ceil(Model.xmin))
		ylen := u64(math.ceil(Model.ymax) - math.ceil(Model.ymin))
		zlen := u64(math.ceil(Model.zmax) - math.ceil(Model.zmin))

		m := make([dynamic]string, 0, 100)
		blocks := make([]u8,xlen*zlen*ylen)
		// 0 = air
		total := 0
		i : int = 1
		append(&m, "")
		for p, j in structure.pos {
				value := clr.color_to_block(structure.colors[j], palette)
				idx := contains(&m, value)
				if idx == -1 {
						//m[i] = value
						append(&m, value)
						i += 1
				}
				indx := pos_to_index(p, xlen, ylen, zlen, {Model.xmin, Model.ymin, Model.zmin})
				blocks[indx] = cast(u8)idx
				total += 1
		}
		fmt.println(total)
		return blocks, m
}

obj_schem_color :: proc(Model : ^load_obj.Obj, palette: ^clr.block_map) {
		size : [3]u32 = load_obj.get_obj_size(u32, Model)

		data0 := []byte {
				0x0A, 0x00, 0x09, 0x53, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x74, 0x69, 0x63, 0x03, 0x00, 0x0A, 0x50, 
				0x61, 0x6C, 0x65, 0x74, 0x74, 0x65,0x4D, 0x61, 0x78,
		}

		//paletteMax : u32
		// paletteMax was replaced by the material length
		data1 := []byte {
				0x0A, 0x00, 0x07, 
				0x50, 0x61, 0x6C, 0x65, 0x74, 0x74, 0x65,
		}
		// TODO I need to generate all of the materials
		//palette
		data2 := []byte {
				0x00, 0x03, 0x00, 0x07, 0x56, 0x65, 0x72, 0x73, 
				0x69, 0x6F, 0x6E, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x06, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68,
		}
		//length
		data3 := []byte {
				0x0A, 0x00, 0x08, 0x4D, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x03, 0x00, 0x09, 0x57, 0x45, 
				0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x58, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x09, 0x57, 0x45, 
				0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x59, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x09, 0x57, 0x45, 
				0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x5A, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x02, 0x00, 0x06, 0x48, 
				0x65, 0x69, 0x67, 0x68, 0x74,
		}
		//Height
		data4 := []byte {
				0x03, 0x00, 0x0B, 0x44, 0x61, 0x74, 0x61, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x00, 0x00, 
				0x0D, 0x89, 0x07, 0x00, 0x09, 0x42, 0x6C, 0x6F, 0x63, 0x6B, 0x44, 0x61, 0x74, 0x61,
		}		
		data5 := []byte {
				0x09, 0x00, 0x0D, 0x42, 0x6C, 0x6F, 0x63, 0x6B, 0x45, 0x6E, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x0A, 0x00, 0x00, 
				0x00, 0x00, 0x02, 0x00, 0x05, 0x57, 0x69, 0x64, 0x74, 0x68,
		}
		//width
		data6 := []byte {
				0x0B, 0x00, 0x06, 0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 
				0xD3, 0xFF, 0xFF, 0xFF, 0xC4, 0x00, 0x00, 0x01, 0xB0, 0x00,
		}

		//TODO ruct positions to blocks

		ray : load_obj.Ray
		ret : load_obj.Ruct
		ret.colors = make([dynamic][4]u8, 0)
		ret.pos = make([dynamic][3]f32, 0)
		volumex : load_obj.BVH
		volumey : load_obj.BVH
		volumez : load_obj.BVH

		ray.dir = [3]f32{0,1,0}
		/* fdir := load_obj.Dir.y */
		/* load_obj.init_BVH(Model, fdir, &volumey) */
		load_obj.init_BVH_box(Model,{&volumex,&volumey,&volumez})
		structure := load_obj.simd_trace_face_bvh(Model, &ret, ray, &volumey)

		ray.dir = [3]f32{1,0,0}
		/* fdir = load_obj.Dir.x */
		/* load_obj.init_BVH(Model, fdir, &volumex) */
		structure  = load_obj.simd_trace_face_bvh(Model, &ret, ray, &volumex)

		ray.dir = [3]f32{0,0,1}
		/* fdir = load_obj.Dir.z */
		/* load_obj.init_BVH(Model, fdir, &volumez) */
		structure  = load_obj.simd_trace_face_bvh(Model, &ret, ray, &volumez)

		/* structure := load_obj.trace(Model) */
		blocks, bmap := ruct_to_u8_array(structure^, Model, palette)
		defer delete(bmap)
		defer delete(blocks)
		block_length := u32(len(blocks))
		/* fmt.println(bmap) */

		using end

		of, err := os.open("turtle.schem", os.O_CREATE)
		if err != 0 {
				fmt.println(err)
		}
		defer os.close(of)
		buf, _ := make([]u8, 4)
		buf2, _ := make([]u8, 2)
		defer delete(buf)
		defer delete(buf2)


		os.write(of, data0)
		// paletteMax
		put_u32(buf, Byte_Order.Big, u32(len(bmap)))
		os.write(of, buf)
		os.write(of, data1)
		// palette
		j := 0
		bmap[0] = "air"
		prefix : string = "minecraft:"
		for s in bmap {
				material_name_length : u16 = u16(len(s)+len(prefix))
				material: string = s
				os.write(of, {0x03})
				put_u16(buf2, Byte_Order.Big, material_name_length)
				os.write(of, buf2)
				os.write(of, transmute([]u8)prefix)
				os.write(of, transmute([]u8)material)
				put_u32(buf, Byte_Order.Big, u32(j))
				os.write(of, buf)
				j += 1
		}
		os.write(of, data2)
		//length
		put_u16(buf2, Byte_Order.Big, cast(u16)size[0])
		os.write(of, buf2)
		os.write(of, data3)
		//height
		put_u16(buf2, Byte_Order.Big, cast(u16)size[1])
		os.write(of, buf2)
		os.write(of, data4)
		put_u32(buf, Byte_Order.Big, block_length)
		os.write(of, buf)
		os.write(of, blocks)
		os.write(of, data5)
		//width
		put_u16(buf2, Byte_Order.Big, cast(u16)size[2])
		os.write(of, buf2)
		os.write(of, data6)

		defer load_obj.delete_ruct(structure^)

}

pos_to_index :: proc(pos : [3]f32, xlen, ylen, zlen : u64, toz : [3]f32) -> u64 {
		x := u32(math.floor((pos[0]-toz[0]))+1)
		y := u32(math.floor((pos[1]-toz[1]))+1)
		z := u32(math.floor((pos[2]-toz[2]))+1)
		x = x*cast(u32)zlen
		y = (y*cast(u32)xlen)*cast(u32)zlen

		return cast(u64)(x + y + z)

}

